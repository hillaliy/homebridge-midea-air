"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const basicAuthParser = require("basic-auth-parser");
const eventemitter3_1 = require("eventemitter3");
const http = require("http");
const net = require("net");
const url = require("url");
const package_json_1 = require("../package.json");
const connectSocket = async ({ cltSocket, hostname, port, head, connect, req, }) => {
    try {
        const srvSocket = await connect(port, hostname, cltSocket, req);
        cltSocket.write(`HTTP/1.0 200 Connection Established\r\nProxy-agent: balena-io/node-tunnel (v${package_json_1.version})\r\n\r\n`);
        srvSocket.write(head);
        srvSocket.pipe(cltSocket, { end: false });
        cltSocket.pipe(srvSocket, { end: false });
        try {
            await new Promise((resolve, reject) => {
                cltSocket.on('error', reject);
                srvSocket.on('error', reject);
                cltSocket.on('end', resolve);
                srvSocket.on('end', resolve);
            });
        }
        finally {
            srvSocket.destroy();
            cltSocket.destroy();
        }
    }
    catch (err) {
        if (cltSocket.writable) {
            cltSocket.end('HTTP/1.0 500 Internal Server Error\r\n');
        }
        if (!cltSocket.destroyed) {
            cltSocket.destroy();
        }
        throw err;
    }
};
class Request extends http.IncomingMessage {
}
exports.Request = Request;
class Tunnel extends eventemitter3_1.EventEmitter {
    constructor() {
        super();
        this.stack = [];
        this.server = http.createServer((_req, res) => {
            res.writeHead(405, { 'Content-Type': 'text/plain' });
            res.end('Method not allowed');
        });
        this.listen = this.server.listen.bind(this.server);
        this.close = this.server.close.bind(this.server);
        this.use(exports.basicAuth);
        this.server.on('connect', async (req, cltSocket, head) => {
            try {
                await this.handleMiddleware(req, cltSocket, head);
                const { hostname, port } = url.parse(`http://${req.url}`);
                if (hostname == null || port == null) {
                    throw new Error('Invalid Request: Hostname or Port missing');
                }
                await connectSocket({
                    cltSocket,
                    hostname,
                    port: parseInt(port, 10),
                    head,
                    connect: this.connect,
                    req,
                });
                this.emit('connect', hostname, port, head);
            }
            catch (err) {
                this.emit('error', err);
                cltSocket.destroy();
            }
        });
    }
    use(middleware) {
        this.stack.push(middleware);
    }
    async handleMiddleware(req, cltSocket, head) {
        await new Promise((resolve, reject) => {
            let index = 0;
            const next = (err) => {
                const middleware = this.stack[index++];
                if (err != null) {
                    reject(err);
                }
                else if (middleware != null) {
                    try {
                        middleware(req, cltSocket, head, next);
                    }
                    catch (err) {
                        reject(err);
                    }
                }
                else {
                    resolve();
                }
            };
            next();
        });
    }
    async connect(port, host, _cltSocket, _req) {
        return new Promise((resolve, reject) => {
            const socket = net.connect(port, host);
            socket.on('connect', () => resolve(socket));
            socket.on('error', reject);
        });
    }
}
exports.Tunnel = Tunnel;
exports.basicAuth = (req, _cltSocket, _head, next) => {
    const proxyAuth = req.headers['proxy-authorization'];
    if (proxyAuth != null) {
        req.auth = basicAuthParser(proxyAuth);
    }
    return next();
};
//# sourceMappingURL=index.js.map